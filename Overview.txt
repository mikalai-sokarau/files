- Что такое React?
- React это библиотека для создания пользовательских интерфейсов. В реакте используется XML подобный синтаксис,
называемый JSX для декларативного описания темплейтов. В реакте используется компонентный подход, когда вся
логика приложения строится отдельными переиспользуемыми блоками.

- Что вы знаете про жизненный цикл компонентов?
- Жизненный цикл компонента делится на 4 блока:
    1. Mounting - создание экземпляра компонента и его рендеринг в DOM.
    2. Updating - обновление компонента в результате изменений в props или state.
    3. Unmounting - удаление компонента из DOM.
    4. Error handling - обработка ошибок.
  ---
    Mounting:
        * constructor(): в нем инициализируется state компонента и происходит
        биндинг (bind) методов. Если нет необходимости в этих действиях, нет смысла реализовывать
        constructor.
        * static getDerivedStateFromProps(props, state): вызывается перед методом render. 
        Этот метод существует для редких случаев, когда state зависит от изменений в props со временем.
        * render(): единственный обязательный для реализации метод в жизненном цикле компонента. 
        Должен содержать чистую функцию, которая не изменяет state компонента и возвращает
        React elements / Arrays and fragments / Portals / String and numbers / Booleans or null.
        * componentDidMount(): вызывается сразу после рендера компонента в DOM. Если есть необходимость
        выполнить какие-либо асинхронные запросы / манипуляции с DOM / подписки на события, это необходимо
        делать здесь.
    Updading:
        * static getDerivedStateFromProps().
        * shouldComponentUpdate(): вызывается перед render, когда приходят новые state / props.
        Этот метод существует только как оптимизация производительности. В нем сравниваются ссылки
        на старые и новые state / props. По умолчанию возвращает true.
        * render().
        * getSnapshotBeforeUpdate(prevProps, prevState): существует для редких случаев, когда
        необходимо собрать информацию для рендеринга из DOM. Возвращает snapshot или null, это
        значение передается в метод componentDidUpdate() в качестве аргумента.
        * componentDidUpdate(prevProps, prevState, snapshot): вызывается сразу после обновления
        компонента. Служит для взаимодействия с DOM, асинхронных запросов, основанных на измененных
        props / state.
    Unmounting: 
        * componentWillUnmount(): вызывается перед удалением компонента из DOM и его разрушением.
        Существует для очистки компонента, например, от существующих таймеров, отмены асинхронных
        запросов и подписок.
    Error handling:
        * componentDidCatch(): вызывается при ошибке во время рендеринга, в методах жизненного цикла или
        в методе constructor() вложенных компонентов. Позволяет отловить случившуюся ошибку и вывести
        сообщение пользователю.
        
- Чем отличается PureComponent от Functional Component?
- PureComponent по умолчанию реализует метод shouldComponentUpdate(), в результате чего метод render() 
вызывается только при новых props / state. Functional Component это чистая функция, в которой нет state
и которая всегда возвращает одинаковую разметку при одинаковых props.

- Что вы знаете про controlled / uncontrolled компоненты?
- Controlled и uncontrolled компоненты используются для обработки данных в форме. Обычно используются
controlled компоненты, к примеру на input вешается обработчик onChange и после каждого введенного
пользователем символа внутри компонента вызывается метод setState(), где в каком-то заданном заранее 
свойстве сохраняется введенный символ, далее вызывается метод render() и содержимое input обновляется.
С помощью uncontrolled компонентов мы можем перенести эту логику в DOM, создать ссылку ref на input
и по событию onSubmit брать данные напрямую из DOM.
У controlled компонентов есть преимущества, позволяющие, к примеру, мгновенно валидировать введенные
пользователем данные, делать активной / не активной кнопку submit и т.п.

- Знаете ли вы чем отличаются presentational от container компонентов?
- Presentational:
    # Заботятся о том как что-то выглядит.
    # Могут содержать presentational и container компоненты внутри. Обычно хранят разметку и стили.
    # Часто рендерят внутри себя this.props.children.
    # Не имеют внешних зависимостей, например подключенного redux store.
    # Получают любые данные снаружи.
    # Не знают о том как данные загружаются или изменяются.
    # Скорее всего написаны как функциональные компоненты, хотя могут быть исключения.
    # Редко используют собственный state, хранят в нем скорее информацию о UI, чем какие-то данные.
  Container:
    # Заботятся о том как что-то работает.
    # Могут содержать presentational и container компоненты внутри. Обычно выступают в качестве обертки
      для внутренних компонентов. Никогда не содержат стили.
    # Хранят / получают данные, необходимые для работы внутренних компонентов.
    # Часто подключены к redux store.
    # Часто stateful так как служат для хранения / изменения данных.
    # Часто создаются при помощи HOC.

- Что вы можете рассказать про reconciliation в react?
- Reconciliation это алгоритм сравнения при помощи которого react решает нужно ли обновлять DOM.
    # В первую очередь сравниваются корневые элементы, если они различаются (к примеру <div/> vs <span/>)
    react перерисовывает все дерево вложенных элементов, при этом все элементы проходят свой обычный
    жизненный цикл.
    # Если элементы одинаковые react проверяет атрибуты элемента и обновляет его в соответствии с новыми
    атрибутами (например изменения в атрибуте "className" или "style"). Так как элемент остается тот же,
    у него сохраняется внутренний state, react вызывает методы жизненного цикла (updating), в render()
    вызывается эта же проверка рекурсивно для всех вложенных элементов.
По умолчанию реакт сравнивает два списка children у элемента, находит различия и запускает механизм
обновления. При этом могут возникнуть проблемы, если вы изменяете коллекцию каких-либо элементов. Бывает
необходимость вставить новый элемент в список уже отрендеренных. При этом если вставлять элемент в начало
списка реакт начнет сравнение с первых элементов, увидит различия и начнет их обновление и так до конца
списка. Это может вызвать проблемы с производительностью. Для решения этой ситуации существует специальный
атрибут 'key'. В его value указывается уникальное и стабильное среди коллекции значение. При сравнении 
списков react находит элементы с одинаковыми value и не обновляет их.

- Как вы понимаете что такое Virtual DOM?
- Virtual DOM это дерево из js объектов которое синхронизированно с DOM-деревом документа. Мы можем
вносить изменения в Virtual DOM, при этом он сравнит 2 дерева и применит изменения в DOM документа.
При вызове функции setState() генерируется новое дерево, которое сравнивается с предыдущим посредством
алгоритма reconciliation.

- Слышали ли вы что-нибудь о React Fiber?
- React Fiber это переписаный алгоритм ядра react, появившийся в 16 версии библиотеки. Его основной целью 
является улучшения взаимодействия react с анимацией, жестами, разметкой страницы. Главная особенность 
Fiber - инкрементальный рендеринг (способность разбивать рендеринг страницы на части и обновлять ее
несколькими фреймами), способность ставить рендеринг на паузу, переиспользовать или отменять в зависимости
от полученных данных, устанавливать приоритет различным типам рендеринга.

- Что такое Higher-Order Components (HOC)?
- HOC это паттерн переиспользования логики компонентов в react. В частном случае это чистая функция которая 
на вход принимает компонент и возвращает новый компонент. Например:
    class Greeting extends React.Component {
        render() {
            return <span>'Hello!'</span>
        }
    }
    function logger(PassedComponent) {
        return class extends React.Component {
            componentDidMount() {
                console.log('mounted');
            }

            render() {
                return <PassedComponent {...this.props}/>
            }
        }
    }
    logger(Greeting);

- Что вы знаете о PropTypes?
- PropTypes это библиотека, которая проверяет соответсвуют ли props, которые получает компонент тому типу
данных, которые он ожидает.

- Что такое Redux?
- Redux это хранилище состояний приложения. В любой момент времени мы можем получить текущее состояние 
приложения. 
Основные принципы redux:
    1. Редакс должен быть единственным источником правды.
    2. Состояние хранилища только для чтения.
    3. Мутации написаны, как чистые функции.
Принцип работы redux:
    1. Создаем store - обычный объект, в котором будем хранить необходимые данные.
    2. Создаем actions - объекты, в которых будут отсылаться данные в store.
    3. Создаем reducer - функцию, которая будет помещать данные в store в соответствии с полученными actions.
Поток данных redux:
    1. Вызывается функция dispatch, которая передает actions в reducer.
    2. Middleware слушает сообщения, посылаемые диспатчером, делает необходимые запросы, отправляет новый action
    c результатами.
    3. Reducer в соответствии с полученным action вычисляет следующий state приложения.
    4. В store сохраняется полученный state.
Для подключения redux в react приложение существует npm модуль react-redux. С помощью Provider в корневую 
точку приложения подключается store и он становится доступен в любом компоненте с помощью функции connect().

- Как redux работает с side-effects?
- В redux единственным местом, где происходят изменения является reducer, а он обязан быть чистой функцией.
Для решения этой проблемы вводится понятие middleware. Middleware - это место через которое проходят все
actions перед попаданием в reducer и из которого мы можем посылать асинхронные запросы. Наиболее популярными 
middleware для redux являются redux-thunk и redux-saga.

- Какой принцип работы у redux-saga?
- Redux-saga это функция-генератор

