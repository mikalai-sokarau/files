jsx - синтаксическое расширение javascript, для описания UI, компилируемое в элементы Реакта и дальше в обычный js.
Компоненты реакта совмещают в себе логику и разметку.
Реакт не требует принудительного использования jsx, но может выводить полезные сообщения об ошибках и варнингах.
В jsx безопасно вставлять данные, введенные пользователем, они не исполняются, а возвращаются в виде строки.

В реакте в фигурные скобки можно помещать любой валидный js код.

----------

Элементы это наименьшие строительные блоки реакт приложений (<h1></h1>, <div></div> ...).
Приложения написаные только на реакте имеют одну входную точку (root), если реакт используется в качестве сторонней библиотеки, можно встраивать куда угодно.

Все реакт элементы иммутабл, создав элемент один раз, вы не можете изменить его детей или атрибуты. Но заменяя один элемент другим, реакт сравнивает их и обновляет только изменившиеся части.

----------

Компоненты это независимые переиспользуемые части реакта. В js можно сравнить с функциями, они принимают на вход данные (props) и возвращают реакт элемент, описывающий что должно появиться на  экране.
Именовать props нужно в контексте компонента, а не в контексте данных, которые в них используются. Props доступны только для чтения
Компоненты всегда должны начинаться с большой буквы. Компоненты написаные с маленькой буквы реакт считает обычными ДОМ элементами.
Если компоненты используются несколько раз или слишком большие по размеру, это хороший знак для того, чтобы разбить их на более мелкие.

----------

В больших приложениях очень важно освобождать ресурсы компонентов, на которые они подписаны при разрушении.
Реакт может группировать несколько setState() вызовов в один ради производительности. Из-за того что this.props и this.state могут обновляться асинхронно мы не можем рассчитывать на них для вычисления следующего state. Для решения этой ситуации существует вторая форма записи setState(), которая принимает на вход функцию. Функция получает первым параметром предыдущий state, а вторым props, применяемые на время апдейта.

----------

Реакт использует синтетические события.
preventDefault нужно вызывать явно. 
<button onClick={(e) => this.handleClick(e)} /> - каждый раз при рендере создается новая функция. При передаче ее в пропсах у children будет вызываться метод рендер, т.к. пришли новые пропс. Лучше биндить методы класса явно в конструкторе или использовать экспериментальный синтаксис myFunc = () => {...}

----------

Reconciliation.
ДОМ элементы разных типов - когда приходят элементы разных типов реакт полностью перерендывает дерево элементов. Старые элементы получают componentWillUnmount() хук, а затем componentDidUnmount(). Если внутри этих элементов есть компоненты, они так же полностью перерендываются, теряют свой стэйт и пропс.
Если ДОМ элементы одного типа, реакт отслеживает изменения и обновляет только их. И т.д. рекурсивно по дереву компонентов.
Компоненты одного типа сохраняют свой стейт, но получают новые пропсы, вызываются хуки componentWillReceiveProps() и componentWillUpdate(), а затем render().

Keys.
Когда реакту приходит новый элемент в список, он сравнивает его по аттрибуту key, вычисляет место в которое его нужно вставлять, остальные элементы не перерендерываются. В качестве key необходимо брать уникальные значения, такие как id. Key должен быть уникальным только среди своей коллекции, а не среди всего приложения.

-----------

HOC - чистая функция, которая принимает компонент и возвращает новый компонент не используя наследование (это больше похоже на контейнер). Служит для создания компонентов с похожим кодом.

-----------

Lifecycle hooks.
constructor(props) нужно вызывать super(props) явно или props будут undefined. Обычно constructor используется для того чтобы объявить state и прибиндить event handlers к экземпляру объекта.

shouldComponentUpdate(nextProps, nextState) не вызывается при первом рендеринге или когда испол ьзуется forceUpdate().

componentDidUpdate(prevProps, prevState, snapshot)

componentWillUnmount() вызывается один раз на этапе уничтожения объекта, этот экземпляр больше никогда не будет отрендерен снова.

-----------

Controlled/uncontrolled components - используются в формах.
Controlled components - компоненты, где реакт является единственным источником правды для данных.
Uncontrolled components - компоненты, где данные обрабатываются в DOM, а не внутри компонента.

----------

Refs - позволяет получить прямой доступ к элементу DOM или состоянию компонента.
